/* 
 * Kalen Dubrick
 */

import java.net.*;
import java.io.*;
import java.util.*;

public class ThreadedPrintServerAdvNet implements Runnable
{
	private int port, MaxConnections;
	private Vector<Job> JobQueue;
	
	public ThreadedPrintServerAdvNet() {}
	public ThreadedPrintServerAdvNet(int port, int maxConnections)
	{
		this.port = port;
		this.MaxConnections = maxConnections;
		this.JobQueue = new Vector<Job>();
		
		// start your printer here
		PrintThread pt = new PrintThread (this.JobQueue);
		pt.start();
		
		// start your computing thread here
		
	}
	
	public void run()
	{
		Connection currentThread = (Connection)Thread.currentThread();
		try
		{
			handleConnectionObj(currentThread.getSocket());
		}
		catch (Exception e) { e.printStackTrace(); }
	}
	
	public int getPort()
	{
		return port;
	}
	
	public void setPort(int port)
	{
		this.port = port;
	}
	
	public int getMax()
	{
		return MaxConnections;
	}
	
	public void setMax(int maxConnections)
	{
		this.MaxConnections = maxConnections;
	}
	
	public void listen() // standard name for server method
	{
		System.out.println("The server is running");
		
		int i = 0;
		
		try
		{
			ServerSocket listener = new ServerSocket(this.port);
			
			while (i < MaxConnections)
			{
				// instead of simply call a method, we need to create thread to handle
				// accept for any connection from client
				Socket serverSideSocket;
				serverSideSocket = listener.accept();
				i++;
				//end to end connection (i.e., a socket) with client
				//handleConnectionObj(serverSideSocket); // communicate with client by using this section
				Connection cn = new Connection(this, serverSideSocket, i);
				cn.start();
			}
		}
		catch (Exception e) 
		{ 
			e.printStackTrace();
		}
	}
	
	public void handleConnectionObj(Socket server) throws IOException
	{
		ObjectOutputStream objOut = new ObjectOutputStream
						(new BufferedOutputStream(server.getOutputStream(), 2048));
		objOut.flush();
		ObjectInputStream objIn = new ObjectInputStream
						(new BufferedInputStream(server.getInputStream()));
		
		try
		{
			Job job = (Job)objIn.readObject();
			this.JobQueue.add(job);
			System.out.println("The Job ID is " + job.getJobID() + 
					" and the number of ops is " + job.getOPNumber());
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}	
		
		objOut.close();
        objIn.close();
        server.close();    
	}
}

class Connection extends Thread
{
	private Socket serverSideSocket;
	
	public Connection(Runnable obj, Socket s, int id)
	{
		super(obj, "server thread " + id);
		serverSideSocket = s;
	}
	
	public Socket getSocket()
	{
		return serverSideSocket;
	}
}

class PrintThread extends Thread
{
	private Vector<Job> jobQ;
	private boolean stop = false;
	
	public PrintThread(Vector<Job> v)
	{
		super("ThePrintingThread");
		this.jobQ = v;
	}
	
	public void run()
	{
		while(!stop)
		{
			
			while (!jobQ.isEmpty())
			{
				int i = 0;
				for (i = 0; i < jobQ.size(); i++)
				{
					Job job = jobQ.firstElement();
				
					int opn = job.getOPNumber();
					Vector<Operation> opv = job.getOPs();
					boolean removable = false;
				
					for (int j = 0; j < opn; j++)
					{
						Operation op = opv.elementAt(j);
						
						System.out.println(op.getOPID());
					
						if (!op.isDone() && op.getOPID() == 1)
						{
							// print the job description to simulate the printing
							System.out.println("The operation type is 1 for Job " + op.getJobID());
							op.setIsDone(true);
						}
						else
						{
							if (!op.isDone())
								removable = false;
							else
								removable = true;
						}
					}
				
					if (removable)
					{
						jobQ.remove(job);
						i--;
					}
				}
			}
				try
				{
					PrintThread.sleep(10);
				}
				catch (Exception e) { e.printStackTrace(); }
				// if no job, thread block itself to yield CPU
		}
	}
}
